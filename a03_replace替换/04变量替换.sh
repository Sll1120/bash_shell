#!/bin/bash
# **********************************************************
# * Author : liangliangSu
# * Email : sll917@hotmail.com
# * Create time : 2023-01-30 15:35
# * Filename : 04变量替换.sh
# **********************************************************
echo '(1)-----------------------完美分割线--------------------------------'
: '
变量替换
可以理解成就是不改变原有变量的情况下，对变量进行替换。
从格式上来看和sed命令很类似！
总之记住 ：
 / 表示替换匹配的第一个字符串；
//  表示替换匹配的所有字符串；
'
# ${变量/旧字符串/新字符串}  替换变量内的旧字符串为新字符串，只替换一个
# 将小写的d替换成大写的D
domain=daidai.com
echo ${domain/d/D}

# ${变量//旧字符串/新字符串}  替换变量内的旧字符串为新字符串，替换全部
echo ${domain//d/D}

# 可以替换字符串,也有删除作用
echo ${domain/daidai/}

# 替换变量场景
# 需求：变量  
# string="The GPL is an open source license, and the GPL is an excellent open source project"
# 执行脚本后，打印输出变量内容，并给出用户以下选项：
#打印string长度
#删除字符串中所有的GPL
#替换第一个GPL为BSD
#替换全部的GPL为BSD
#编写思路：
#首先定义 string的变量和内容，并且打印出来；
echo '(2)-----------------------完美分割线--------------------------------'
#然后，定义用户选项，利用cat <<EOF ,注意里面的不要有单引号，要不然会认为成一个变量了！
#执行后的结果：
#给出了选项，就需要利用到read 交互模式进行选择选项了。
#read 介绍
#Shell变量除了可以直接赋值，或者脚本传参外，
#还可以使用read命令从标准输入中获得！主要作用交互式接受用户输入，然后给变量赋值；
#因为 read 是系统的bash内置命令，除了在网上查询，可以 man read
#语法格式：
#-p  设置提示信息；
#-t   设置输入等待的时间，单位默认为秒
#read -p "请输入你要操作的编号 [1 | 2 | 3 | 4]:"   Action
#最后要进行选项判断了。
#如何得到第一个选项的字串串的长度？
#用最短匹配规则来取值，而不是用 wc 来取值
#如果用wc来取值也是可以的！
echo ${string} | wc -L
#接下来，就需要写一些判断语句了
#1 定义用户变量并打印
string="The GPL is an open source license, and the GPL is an excellent open source project"
echo ${string}
#2 给出用户选项
echo ""
cat <<EOF
1)打印string长度
2)删除字符串中所有的GPL
3)替换第一个GPL为BSD
4)替换全部的GPL为BSD
EOF
while true; do
	read -p "请输入你要操作的编号 [1 | 2 | 3 | 4]:" Action
	if [ $Action -eq 1 ]; then
		echo ${#string}
	elif [ $Action -eq 2 ]; then
		echo ${string//GPL/}
	elif [ $Action -eq 3 ]; then
		echo ${string/GPL/BSD}
	elif [ $Action -eq 4 ]; then
		echo ${string//GPL/BSD}
	else 
		echo "超出以上选择范围"
		exit 0
	fi
done

#这代码很臃肿弊端就是很臃肿！
#测试执行，没有问题
#这个脚本的有个体验不好的就是，在选择选项的时候，只能选择一次后执行，还需要再次调用这个脚本，这就需要介入一些循环的判断的语法。
#用crtl+c结束
#规范的缩进方法就是将判断包裹在循环里

	#提取内存百分比脚本
#需求：如果使用率超过80%，触发报警并发邮件
#编写思路：
#如何查看内存指标？
#如何查看内存使用率百本分比？
#重点在于用最短删除匹配原则（从后往前删）来进行比对。
#查看内存的命令如下，获取百分比用used的值除以total总计再乘以100。
#那么怎么取值的呢？这就需要awk，取Mem这一列的值了。
#先以Mem打头进行awk
#[root@centos7 ~]# free -m | awk '/^Mem/'
#根据取内存百分比的算法，要用used的值（第三列）除以total的值（第二列）再乘以100.
#[root@centos7 ~]# free -m | awk '/^Mem/ {print $3/$2*100}'
#如图所示：拿到了内存的使用率。
#再与定义的阈值（80%）作比对，超过发送邮件报警，否则没有任何提示！
#先定义一个内存使用率的变量，一定用小括号表示，因为这是个系统命令，而不是人为定义的变量，但是取值的结果是小数，没有办法和整数的80%作比对~
#用最短的删除匹配原则可以解决这个小数点后面的数字（从后往前）！
#加入判断语句进行比对！
#- ge 是大于的意思！
#注意这里要用%接住最后的数值结果
#echo "主机123.60.219.53内存超过了80%，当前已经使用了 ${Free_use}%"
#在测试中，由于80%多大，我将这里的阈值调小，从而证明脚本判断是没有问题的！
#为不同版本系统安装yum源（epel源等同）
#编写思路：
#判断不同的系统版本。（分别拿Centos7和Centos6来进行比对）
#根据不同系统安装不同的epel源。
#取值版本的命令在Centos7和6中，方式也不太一样！
#7支持hosnamectl内置命令
#而6不行！只能通过 cat /etc/redhat-release 这条命令来区分
#接下来，就需要将这里的系统值取出
#在cent0s7中，利用awk取最后一列并减一
#NF代表了总列数
#但是这样取出的值是带有小版本号，不利于后期对对大版本号的判断！
#利用最长删除匹配原则，从后往前删，取到大版本号（6版本系统也是一样！）
#最后加上判断和动作即可！
#将执行结果重定向到空文件。
#针对如何更改yum或epel源，可以参考阿里云镜像站https://developer.aliyun.com/mirror/
#shell变量的默认值
#这个默认值其实也算是Shell的特殊扩展变量。
#默认值分为三种，主要作用就是测试变量是否未赋值！
#${yyy:-xxx}  
#若变量yyy为空时，则用xxx 作为变量yyy的值；
#若变量yyy不为空，则直接使用变量yyy的值；
#${yyy:=xxx}  
#若变量yyy为空时，则用xxx 作为变量yyy的值，同时将xxx赋予变量yyy;
#若变量yyy不为空时，则直接使用yyy的值；
#${yyy:=xxx}很常用的一种用法是，判断某个变量是否赋值，没有的话给它赋上一个默认的值！（用的比较多，通常用作安装程序！）
#${yyy:+xxx}
#若变量yyy为空时，则不替换或者说是替换成变量 yyy的值，即空值（因为变量yyy此时为空，所以这两种说法是等价的！）。
#若变量yyy不为空时，则用xxx 作为变量yyy的值，同时将xxx赋值给yyy变量；
#具体演示如下
#编写一个变量${yyy:-xxx} 
#执行变量时，在交互输入回车，显示为空，并没有打出所谓的路径
#当添加变量默认值时，执行脚本交互再回车时，会将默认的值回显到屏幕上！默认变量的作用使用户交互起来更加友好！（安装场景，猛击回车一路下一步）
#但是如果在这个脚本执行时，自己指定了一个路径，那么会按照自己指定的那个路径为优！
#最后的总结：
#编写一个变量${yyy:=xxx} 
#如图：不给值，也按照默认值赋值给installs这个变量！
#和 - 区别主要就在这，会将值赋值给对应的变量！
#编写一个变量${yyy:-xxx} 
#用的场景不多。主要是为空还是为空，没啥意义！即使替换了，最终installs 的值还是默认值。
